<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sustainability Game</title>
    <script src="https://code.jquery.com/jquery-3.7.0.js" integrity="sha256-JlqSTELeR4TLqP0OG9dxM7yDPqX1ox/HfgiSLBj8+kM=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src='templates/sustemplates.js'></script>
    <script src='templates/suspartials.js'></script>
    <link rel='stylesheet' href='css/basics.css'>
    <link rel='stylesheet' href='css/player.css'>
</head>

<body>
    <h1>Sustainability Game</h1>
    <div id='warning'><span id='warning_message'>close this stuff down</span> <div class='closer'>x</div></div>
    <div class='info_box' id='info_resources'>
        <p>resources</p>
        <p>remaining</p>
        <p id='remain' class='resources highlight'>10</p>
    </div>
    <div class='info_box' id='info_votes'>
        <p>votes</p>
        <p>received</p>
        <p id='votes_received' class='votes_received highlight'></p>
    </div>
    <div id='overlay'>


    </div>
    <div id='insertion'></div>

    <script>
        const socket = io();
        let butt = null;
        let txt = null;
        let staticID = null;
        let env = null;
        let clientData = {role: 'player'};
        let player = null;
        let suspend = false; /* suspend is true when the server connection is down */

        Handlebars.registerHelper('playerPartial', function(partialName, context) {
            const partial = Handlebars.partials[partialName];
            if (typeof partial === 'function') {
                return new Handlebars.SafeString(partial(this));
            }
            return '';
        });

        const log = (msg) => {
            let i = 'log_' + Object.keys(logList).length;
            logList[i] = msg;
//            console.log(i, msg);
        };
        const getLogs = () => {
            for (var i in logList) {
//                console.log(`${i}: ${logList[i]}`);
            }
        };
        const debugServer = (str) => {
            // De-comment the below line with care, it results in heavy server load if many clients are connected
//            socket.emit('clientDebug', str);
        };
        //
        const onRequestSession = (o) => {
            if (o.player === staticID) {
                if (o.success) {
                    refreshView();
                } else {
//                    alert(`no session with ID ${txt.value} exists`);
                    showWarning(`no session with ID ${txt.value} exists`);
                    showWarning(`no session with ID ${$('#seshnum').val()} exists`);
                }
            }
        };
        let requestSession = null;
        // requestSession is defined in the newlogin template
        const getHash = () => {
            let h = '';
            if (window.location.hash && isDev) {
                if (window.location.hash.substr(0, 1) === '#') {
                    h = window.location.hash.replace('#', '');
                    if (h.indexOf('?', 0) > -1) {
                        h = h.split('?')[0];
                    }
                }
            }
//            console.log(`getHash: ${h}, isDev: ${isDev}`);
//            console.log(JSON.parse(JSON.stringify(window.location)))
            return h;
        };
        const getStorageID = () => {
            let sid = `player${getHash()}ID`;
//            console.log(`sid set to ${sid}`);
            return sid;
        };
        const getUniqueStorageID = (id) => {
            return `${getStorageID()}-${id}`;
        };
        const generateID = () => {
//            console.log(`gen id`);
            let id = 'player-' + Math.round(Math.random() * 1000);
            if (window.location.hash) {
                if (window.location.hash.substr(0, 1) === '#') {
                    id = id.replace('-', '-' + window.location.hash.replace('#', '') + '-');
                    if (id.indexOf('?', 0) > -1) {
                        id = id.split('?')[0];
                    }
                }
            }
            if (id) {
                staticID = id;
                localStorage.setItem(getStorageID(), JSON.stringify({id: staticID}));
            }
            return id;
        };
        const getID = () => {
            let id = localStorage.getItem(getStorageID());
//            console.log(`getID; retrieve id from localStorage: ${id}`);
//            console.log(`storedID: ${id}`);
//            console.log(`staticID: ${staticID}`);
            if (!id) {
                id = generateID();
            } else {
                // we have the local storage object, now we must extract the id from it:
//                console.log('id:');
//                console.log(id);
                id = JSON.parse(id).id;
                staticID = id;
//                console.log(`ID retrieved from localStorage: ${id}`);
            }
//            staticID = id;
            return id;
        };
        const getMinID = () => {
            let id = getID().replace(env.gamedata.prefixes.player, '');
//            console.log(`getID call; getMinID method: ${id}`);
            return id;
        };
        const prepPlayer = (p) => {
            // Output a player object based on a retrieved object
            let s = p.stakeholder;
            p.stakeholderID = s;
            if (s < 0) {
                p.stakeholder = 'unassigned';
            } else {
                p.stakeholder = Object.values(env.gamedata.teams)[s].title;
            }
//            console.log(p);
            return p;
        };
        const finalisePlayer = (p) => {
            // Make any final tweaks to the player object before it is sent to the templates for rendering
            if (p.mainTeams && p.teamObj) {
                p.mainTeams.forEach((t) => {
                     t.isMyTeam = t.id === p.teamObj.id;
                });
            }
            if (p.teamObj) {
//                console.log(p.teamObj);
                if (p.teamObj.hasLead) {
                    p.actions = p.teamObj.hasOwnProperty('actions') ? p.teamObj.actions : env.gamedata.actions;
                }
            }
//            console.log(p);
            return p;
        };
        const newPlayer = () => {
//            console.log(`newPlayer called, id: ${id}`);
//            storageID = getStorageID();
//            document.title = id;
            player.enrolled = true;
//            $('h2').html(`id: ${id}`);
//            socket.emit('addNewPlayer', {id: id}, (response) => {
//                gameInit();
//            });
//            console.log(`newPlayer calls refreshView`);
            refreshView('newPlayer');
            gameInit();
        };
        const gameInit = () => {
//            console.log(`gameInit`);
            // this code is open to abuse, replace it with insertion of template HTML
            let sessionID = txt.value;
            renderGameScreen();
        };
        const clearPersistence = () => {
            localStorage.clear();
        };
        const kickout = () => {
            renderTemplate('outtro', 'insertion');
            clearPersistence();
        };
        const evicted = () => {
            renderTemplate('kickedout', 'insertion');
        };
        const refreshMe = () => {
//            console.log(`I want refreshment`);
            window.location.reload()
        };
        const renderTemplate = (temp, targ, o) => {
            targ = '#' + targ;
            let ob = Object.assign({}, o);
            const compiledTemplate = Handlebars.templates[temp];
            const renderedHtml = compiledTemplate(ob);
            $(targ).html('');
//            console.log('re-render');
//            console.log(`renderTemplate ${temp} ${targ}`);
            $(targ).html(renderedHtml);
        };
        const getTemplate = () => {

        };
        const setState = (o) => {
            // record a state for the page to return to upon refresh
            localStorage.setItem(getUniqueStorageID('state'), JSON.stringify(o));
        };
        const updateState = () => {
            // return the page to its present state
            let o = JSON.parse(localStorage.getItem(getUniqueStorageID('state')));
            if (o) {
                if (o.hasOwnProperty('length')) {
                    o.forEach((v) => {
//                        console.log(v);
//                        console.log(v.disabled);
//                        console.log(typeof(v.disabled));
                        $(`#${v.option}`).val(v.val);
                        $(`#${v.option}`).attr('disabled', v.disabled);
                        $(`#${v.button}`).attr('disabled', v.disabled);
//                        console.log($(`#${v.button}`));
//                        debugger;
                    });
                } else {
                    for (var i in o) {
                        if ($(`#${i}`).length > 0) {
                            $(`#${i}`).val(o[i]);
                            $(`#${i}`).attr('disabled', true);
                        }
                    }
                }
            }
        };
        const updateValues = (pl) => {
            if (pl) {
                $('#info_resources').show();
                $(`.resources`).html(pl.teamObj.votes);
                if (pl.teamObj.votesReceived) {
                    $('#info_votes').show();
                    $(`.votes_received`).html(pl.teamObj.votesReceived);
                }
            }
        };
        const renderGameScreen = () => {
            let o = {
                playerID: staticID
            };
            socket.emit('getPlayerPack', (o) => {
                let steak = player.stakeholderID;
                player = prepPlayer(o.playersDetail[getMinID()]);
                if (o.session.assigned) {
                    if (player.stakeholderID > -1) {
                        let mainTeam = Object.values(env.gamedata.teams)[player.stakeholderID].hasMax;
                        player.partialName = mainTeam ? 'stakeholder' : 'publicvoices';
                        if (player.isLead && document.title.indexOf('*', 0) < 0) {
                            document.title = `* ${document.title}`
                        }
                    }
                }
                player = Object.assign(env.gamedata, player);
                player = finalisePlayer(player);
                if (steak !== player.stakeholderID) {
                    // Only render if the stakeholder has changed -  may need to add other conditions later
                    renderTemplate('game', 'insertion', player);
                    updateState();
                }
            });
        };
        const onNewSession = () => {
            // Reload the page rather than refresh view - this enables script to run successfully on rendered page
            // Note: prior call to 'onStoredGameFound' causes a refresh, hence the flicker. Consider a way to remove this in future.
            clearPersistence();
            // Keep the line below in place for now, but work to remove it later.
            // Move the login code off the template and into the main page - page refreshing sucks.
            window.location.reload();
//            refreshView('onNewSession');
        };
        const updateMaxVotes = (m) => {
            max = m;
            $('#votes').html(m);
            console.log(`set max to ${m}`);
        };
        const connectionWarning = (boo) => {
//            console.log(`connectionWarning: ${boo}`);
            if (boo) {
                $('#overlay').html('');
            } else {
                renderTemplate('serverlost', 'overlay');
            }
//            clearTimeout(cInt);
//            cInt = setTimeout(() => {
//                if (boo) {
//                    $('#overlay').html('');
//                } else {
//                    renderTemplate('serverlost', 'overlay');
//                }
//            }, 2000);
        };
        const serverShutdown = () => {
//            $('body').fadeOut(2000);
            connectionWarning(false);
            suspend = true;
//            clearTimeout(cInt);
//            cInt = setTimeout(() => {
//                connectionWarning(false);
//            }, 2000);
        };
        const onPinged = () => {
//            $('H1').delay(10).fadeOut(50).fadeIn();
            let t = document.title;
            let n = 7;
            document.title = `*${t}`;
            let i = setInterval(() => {

                $('H1').css('opacity', `${n%2 === 0 ? 1 : 0.3}`);
                if (n-- === 0) {
                    clearInterval(i);
                    document.title = t;
                }
            }, 200);

        };
        const init = () => {
//            console.log('this is init ');
//            storageID = getStorageID();
//            console.log(`storageID: ${storageID}`)
//            console.log(`init, id: ${id}`)
        };
        let currentState = null;
        const refreshViewCallback = (p) => {
//            console.log(`refreshViewCallback`);
            let id = getMinID();
            let newPlayer = !p.playersBasic.hasOwnProperty(id);
            let enrolled = false;
            if (currentState) {
                let c = currentState !== JSON.stringify(p);
            }
            currentState = JSON.stringify(p);
            if (p.hasOwnProperty('playersDetail')) {
                if (p.playersDetail.hasOwnProperty(id)) {
                    enrolled = p.playersDetail[id].enrolled;
                } else {
//                    console.log(`%cno player with id ${id} found`, `color: red;`);
                }
            }
            if (p.sessionID) {
                if (enrolled) {
                    renderGameScreen();
                } else {
                    if ($('#insertion').find('#login').length === 0) {
                        console.log('render the login');
                        // only render the login if it isn't already there
                        renderTemplate('newlogin', 'insertion', {
                            value: p.isDev ? p.sessionID : ''
                        });
                    }
                }
            } else {
                renderTemplate('intro', 'insertion');
            }
        };
        let refreshing = false;
        const refreshView = () => {
//            console.log(`refreshView`);
//            console.log(`are we already refreshing? ${refreshing}`);
//            console.log(`refreshView, suspend? %c${suspend}`, `color: ${suspend ? 'green' : 'red'}`);
            // Do not run if suspend = true, i.e. server has shit down and is not yet ready to restart
            if (!suspend) {
                // cut out unecessary calls by not calling if a refresh is already in progress
                refreshing = false;
                if (!refreshing) {
                    refreshing = true;
                    socket.emit('getPlayerPack', (p) => {
                        //
                        // can we use the storedData in the playerPack to assess whether the player is enrolled?
                        //
                        refreshing = false;
                        refreshViewCallback(p);
                    });
                }
            } else {
//                console.log(`suspend is true, refreshing is not possible at this time`);
            }
        };
        const getInitProps = () => {
            let o = {};
            let p = window.location.hash;
//            console.log(p);
            if (p && p.indexOf('?', 0) > -1) {
                p = p.split('?');
//                    console.log(p);
                if (p.length > 0) {
//                    console.log(p);
                    p = p[1].split('&');
                    p.forEach((s) => {
                        let ps = s.split('=');
                        o[ps[0]] = ps[1];
                    });
                }
            }
//            console.log(o);
            return o;
        };
        const onConnect = () => {
            connectionWarning(true);
//            console.log('onconnect event');
            socket.emit('getPlayerPack', (p) => {
//                console.log('playerPack')
//                console.log(p)
                isDev = p.isDev;
                env = Object.assign({}, p);
                if (Boolean(p.session)) {
                    let id = getMinID();
                    clientData.id = id;
                    socket.emit('customDataEvent', clientData);
                    id = getID();
                    storageID = getStorageID();
                    document.title = id;
//                    console.log(p);
                    $('h2').html(`id: ${id}`);
                    socket.emit('addNewPlayer', {id: id}, (o) => {
                        player = o.player;
//                        console.log(player);
                    });
                    let sid = false;
                    if (p.storedData) {
                        if (p.storedData.hasOwnProperty('sid')) {
                            sid = p.storedData.sid;
                        }
                    }
                } else {
                    console.log(`no session in progess, don't create a player yet - just show the intro`);
                    renderTemplate('intro', 'insertion');
                }
            });
        };

        let isDev = false;
        let logList = {};

        // Potential univeral code:


        const showWarning = (w) => {
            $('#warning_message').html(w);
            $('#warning').show();
        };
        const closeWarning = () => {
            $('#warning').hide();
        };

        // end potential universal code


        // Type-specific code:

        // Public Voices
        let vb = $('.buttonVote');
        let vv = $('.voteVal');
        let max = 10;
        let ls = [];
        let lid = null;
        const validateVote = (inp) => {
            const value = parseFloat(inp.value);
            if (value > max) {
                inp.value = max;
            }
            if (value < (-1 * max)) {
                inp.value = (-1 * max);
            }
        };
        const submitVote = function (src, toEmit) {
            const vi = src.parent().find('.voteVal');
            let rc = player.teamObj.votes - parseInt(vi.val()) <= 0;
//            console.log(`check the vals, mine: ${vi.val()}, votes: ${player.teamObj.votes}`);
//            console.log(player);
//            console.log(player.teamObj.votes === 0);
//            console.log(`rc ${rc}`)
            vv.each((i, v) => {
//                console.log($(v).val());
            });
            if (!rc) {
                rc = true;
                vb.each((i, v) => {
                    if ($(v).attr('disabled') !== 'disabled') {
//                        console.log(`change to false at ${i}`);
                        rc = false;
                    }
                });
            }
//            let o = {
//                src: player.id,
//                team: player.stakeholderID,
//                targ: parseInt(vi.attr('id').split('_')[1]),
//                v: parseInt(vi.val())
//            };
//            ls[o.targ] = o.v;
//            localStorage.setItem(lid, ls);
//            src.attr('disabled', true);
//            vi.attr('disabled', true);
            let so = {
                src: player.id,
                targ: parseInt(vi.attr('id').split('_')[1]),
                valID: 'vote',
                val: parseInt(vi.val()),
                roundComplete: rc
            }
            registerScore2(so);
//            registerScore(player.id, parseInt(vi.attr('id').split('_')[1]), 'vote', parseInt(vi.val()));
        };
        const submitVoteV1 = function (src, toEmit) {
            const vi = src.parent().find('.voteVal');
            let o = {
                src: player.id,
                team: player.stakeholderID,
                targ: parseInt(vi.attr('id').split('_')[1]),
                v: parseInt(vi.val())
            };
//            console.log('submitVote');
//            console.log(o);
            ls[o.targ] = o.v;
            localStorage.setItem(lid, ls);
            src.attr('disabled', true);
            vi.attr('disabled', true);
//            socket.emit(toEmit, o);

            //
            registerScore(player.id, parseInt(vi.attr('id').split('_')[1]), 'vote', parseInt(vi.val()));
        };
        vv = $('.voteVal');
        const getRemain = () => {
            let m = max;
            if (vv) {
                vv.each(function () {
                    let v = Math.abs(parseInt($(this).val()));
                    m -= v;
//                    console.log(v, m)
                });
            }
            return m;
        };
        const autoCompleteAllocation = () => {
            let sel = $('#actionSelect');
            let desc = $('#actionDesc');
            let val = $('#allocateVal');
            if (!Boolean(sel.val()) && !Boolean(desc.val()) && !Boolean(val.val())) {
                let op = $('#actionSelect option');
                let ri = Math.floor(Math.random() * op.length);
                let ro = op.eq(ri);
                sel.val(ro.val());
                desc.val('a test description');
                val.val(Math.ceil(Math.random() * 4));
                if (Boolean(sel.val()) && Boolean(desc.val()) && Boolean(val.val())) {
                    setTimeout(() => {
                        $('#buttonAllocate').click();
                    }, (500 + (Math.random() * 500)));
                } else {
                    setTimeout(300, autoCompleteAllocation);
                }
            }
        };
        const viewUpdate = () => {
            socket.emit('getPlayerPack', (pp) => {
//                console.log(`viewUpdate`);
//                console.log(pp);
                enableScorePV(pp.session.round > 0);
                if (pp.session.round > 0) {
                    let theDiv = env.gamedata.rounds[pp.session.round].id.split('_')[0];
                    $('.round').hide();
                    $(`#${theDiv}`).show();
                    updateState();
//                    console.log(`show ${theDiv}`);
                    let s = localStorage.getItem(lid);
                    if (s) {
                        debugServer(`stored data: ${s}`);
                        s = s.split(',');
                        max = 10;
                        s.forEach((v, i) => {
                            if (!isNaN(parseInt(v))) {
                                max -= parseInt(v);
                                ls[i] = v;
                                vv[i].value = v;
                                $(vv[i]).attr('disabled', true);
                                $(vb[i]).attr('disabled', true);
                            }
                        });
                    }
//                    console.log('automatic');
//                    console.log(getInitProps().autoenroll);
                    if (theDiv === 'allocation' && getInitProps().autoenroll) {
//                        console.log('automatic');
                        setTimeout(autoCompleteAllocation, (500 + (Math.random() * 1000)));
                    }
                }
            });
        };
        const onSessionUpdate = () => {
            viewUpdate();
//            console.log('session update calls viewUpdate');
        };
        const initpv = () => {
            debugServer('initialise a Public Voice');
            lid = `pv-${getID().split('?')[0]}-vote`;
            vb = $('.buttonVote');
            vv = $('.voteVal');
            vb.on('click', function () {
                submitVote($(this), 'pvStakeholderScore');
            });
            viewUpdate();
            scoreUpdate(getMinID());
        };
        const renderVotes = (p) => {
//            console.log(`renderVotes`);
//            console.log(p);
            let v = p.teamObj.votes;
            let rc = player.teamObj.votes === 0;
            debugServer(`renderVotes called`);
            $('#votes').html(v);
            max = v;
            let c = 1;
            vv.each((i, el) => {
//                console.log(i, $(el).prop('disabled'));
                c+= $(el).prop('disabled') ? 1 : 0;
                if (!$(el).prop('disabled')) {
                    validateVote(el);
                }
            });
//            console.log(`${c} out of ${vv.length}`)
            console.log(`renderVotes: ${c === vv.length}`);
            if (c === vv.length) {
                socket.emit('teamRoundComplete', {team: p.teamObj.id})
            }
            if (v <= 0) {
                $('#votes').addClass('false');
                vb.attr('disabled', true);
                vv.attr('disabled', true);
            }
        };
        const scoreUpdate = (o) => {
            //forget the incoming object, it's a red herring, go to the server for the player object instead
            console.log(`scoreUpdate`);
//            console.log(o);
            socket.emit('getPlayer', getMinID(), (p) => {
//                console.log(`getPlayer CB:`);
//                console.log(p);
                renderVotes(p);
                updateValues(p);
            });
        }
        const scoreUpdateV1 = (o) => {
//            console.log(`scoreUpdate:`);
//            console.log(o);
//            console.log(getMinID());
            // Conditional modified to always be true - this method is sent to all team members, hence can always run. Check to see whether the event is emitted in other methods, if not we can get rid of the conditional, if it is then the conditional needs to be modified to match the team ID.
            if (o.src === getMinID()) {
                console.log(`OK, we can go`);
                socket.emit('getPlayer', o.src, (p) => {
                    console.log(`getPlayer CB:`);
                    console.log(p);
                    renderVotes(p);
                    updateValues(p);
                });
            } else {
                console.warn('ID mismatch, cannot update');
            }
        };
        const enableScorePV = (boo) => {
//            console.log(`enableScorePV`);
            vb.prop('disabled', !boo);
            vv.prop('disabled', !boo);
        };
        $('.buttonVote').on('click', submitVote);

        const setupPV = () => {
            initpv();
        };
        socket.on('scoreUpdate', (o) => {
            scoreUpdate(o);
        });
        // End Public Voices

        // Stakeholder
        const registerScore2 = (o) => {
            socket.emit('getNewScorePacket2', o);
            console.log(o);
            console.log('getNewScorePacket2');
        }
        const registerScore = (src, targ, valID, val) => {
//            console.log(`registerScore`, src, targ, valID, val);
            registerScore2(`registerScore`, src, targ, valID, val);
            socket.emit('getNewScorePacket', src, targ, valID, val, (sp) => {
//                console.log(sp);
            })
        };
        const initst = () => {
            lid = `st-${getID().split('?')[0]}-vote`;
            vb = $('.buttonVote');
            vv = $('.voteVal');
            vb.on('click', function () {
//                console.log('this is the event');
//                console.log($('.voteVal').length);
                let d = $(this).attr('id');
                let o = {};
                let a = [];
                let st = JSON.parse(localStorage.getItem(getUniqueStorageID('state')));
                $('.voteVal').each(function (i, vo) {
                    o = {
                        option: $(this).attr('id'),
                        button: `buttonVote_${$(this).attr('id').split('_')[1]}`,
                        val: $(this).val(),
                        disabled: d.split('_')[1] === $(this).attr('id').split('_')[1]
                    }
//                    console.log(st);
                    if (st) {
                        if (st.hasOwnProperty('length')) {
                            o.disabled = st[i].disabled ? true : o.disabled;
                        }
                    }
//                    o[$(this).attr('id')] = $(this).val();
                    a.push(o);
                });
                setState(a);
                submitVote($(this), 'stStakeholderScore');
            });
            //
            // Allocation - non-collaborative self-allocation of resources
            let ab = $('#buttonAllocate');
            let av = $('#allocateVal');
            let as = $('#actionSelect');
            let ad = $('#actionDesc');
            ab.on('click', function () {

                if (Boolean(as.val()) && Boolean(av.val()) && Boolean(ad.val())) {
                    if (av.val() < 1) {
                        alert('value must be more than 0');
                    } else {
                        let c = getInitProps().autoenroll ? true :  confirm('are you sure?');
                        if (c) {
//                            registerScore(player.id, player.teamObj.id, 'action_name', as.val());
                            registerScore2({src: player.id, targ: player.teamObj.id, valID: 'action_name', val: as.val()});
//                            registerScore(player.id, player.teamObj.id, 'action_desc', ad.val());
                            registerScore2({src: player.id, targ: player.teamObj.id, valID: 'action_desc', val: ad.val()});
//                            registerScore(player.id, player.teamObj.id, 'vote', parseInt(av.val()));
                            registerScore2({src: player.id, targ: player.teamObj.id, valID: 'vote', val: parseInt(av.val()), roundComplete: true});
                            let sto = {
                                allocateVal: av.val(),
                                actionDesc: ad.val(),
                                actionSelect: as.val(),
                                buttonAllocate: ''
                            };
                            setState(sto);
                            let o = {
                                src: player.id,
                                t: player.teamObj.id,
                                action_name: as.val(),
                                action_desc: ad.val(),
                                resource: parseInt(av.val())
                            };
                            ab.attr('disabled', true);
                            av.attr('disabled', true);
                            as.attr('disabled', true);
                            ad.attr('disabled', true);
    //                        scoreUpdate(o);
    //                        socket.emit('allocation1', o);
                        }
                    }
                } else {
                    alert('please complete all options');
                }

            });

            viewUpdate();
        };
        const setupStakeholder = () => {
            initst();
        };

        const validateAllocation = (inp) => {
            const value = parseFloat(inp.value);
            if (value > max) {
                inp.value = max;
            }
            if (value < 0) {
                inp.value = 0;
            }
        };
        // End stakeholder

        // End type-specific code




        socket.on('onRequestSession', (boo) => {
            onRequestSession(boo);
        });
        socket.on('connect', () => {
//            console.log(`connect calls onConnect: ${socket.id}`);
            onConnect();
        });
        socket.on('onStoredGameFound', () => {
//            console.log('onStoredGameFound calls refreshView');
//            suspend = false;
            refreshView(`onStoredGameFound`);
        });
        socket.on('onUpdateTimer', (t) => {
            let p = $('#gameTimer');
            p.html(t);
        });
        socket.on('terminateSession', kickout);
        socket.on('sessionUpdate', onSessionUpdate);
        socket.on('newSession', onNewSession);
        socket.on('serverShutdown', serverShutdown);
        socket.on('ping', () => {
            onPinged();
            console.log(`i got pinged`);
        });
        socket.on('refresh', () => {
            refreshMe();
        });
        socket.on('evict', () => {
            evicted();
        });
        socket.on('onAssignTeams', (id) => {
            return;
//            console.log(`I have a Team: ${id}`);
//            console.log(env.gamedata.teams[id]);
//            console.log(env.gamedata.teams);
            $('#team').find('span').html(env.gamedata.teams[id].title);
//            debugger;
        });
        socket.on('upateMaxVotes', (m) => {
//            console.log('i heard the emission')
            updateMaxVotes(m)
        })
        window.showLog = getLogs;
        window.getRemain = getRemain;
        //
        //        init();

    </script>
</body>

</html>
