<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sustainability Game</title>
    <script src="https://code.jquery.com/jquery-3.7.0.js" integrity="sha256-JlqSTELeR4TLqP0OG9dxM7yDPqX1ox/HfgiSLBj8+kM=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src='templates/sustemplates.js'></script>
    <script src='templates/suspartials.js'></script>
    <link rel='stylesheet' href='css/basics.css'>
    <link rel='stylesheet' href='css/player.css'>
</head>

<body>
    <h1>Sustainability Game</h1>
    <div id='warning'><span id='warning_message'>close this stuff down</span> <div class='closer'>x</div></div>
    <div class='info_box' id='info_multiplier'>
        <p>multiplier</p>
        <p id='multiplier' class='multiplier highlight'></p>
    </div>
    <div class='info_box' id='info_votes'>
        <p>votes</p>
        <p>received</p>
        <p id='votes_received' class='votes_received highlight'></p>
    </div>
    <div class='info_box' id='info_totalscore'>
        <p>total</p>
        <p id='totalscore' class='totalscore highlight'></p>
    </div>
    <div class='info_box' id='info_resources'>
        <p>resources</p>
        <p>remaining</p>
        <p id='remain' class='resources highlight'>10</p>
    </div>
    <div id='scoresheet' class=''>

    </div>
    <div id='scoredisplay' class=''>

    </div>
    <div id='overlay'>


    </div>
    <div id='insertion'></div>

    <script>
        const socket = io();
        let butt = null;
        let txt = null;
        let staticID = null;
        let env = null;
        let clientData = {role: 'player'};
        let player = null;
        let suspend = false; /* suspend is true when the server connection is down */
//        let autoCompleteAllowed = true;

        Handlebars.registerHelper('playerPartial', function(partialName, context) {
            const partial = Handlebars.partials[partialName];
            if (typeof partial === 'function') {
                return new Handlebars.SafeString(partial(this));
            }
            return '';
        });
        Handlebars.registerHelper('dynamicPartial', function(partialName, options) {
            // Check if the partialName is defined and is a valid partial
            if (Handlebars.partials[partialName]) {
                // Include the specified partial
                return new Handlebars.SafeString(Handlebars.partials[partialName](this));
            } else {
                // Handle the case where the specified partial is not found
                return new Handlebars.SafeString('Partial not found');
            }
        });
        const log = (msg) => {
            let i = 'log_' + Object.keys(logList).length;
            logList[i] = msg;
//            console.log(i, msg);
        };
        const getLogs = () => {
            for (var i in logList) {
//                console.log(`${i}: ${logList[i]}`);
            }
        };
        const debugServer = (str) => {
            // De-comment the below line with care, it results in heavy server load if many clients are connected
//            socket.emit('clientDebug', str);
        };
//        class ScoreReport
        //
        const onRequestSession = (o) => {
            if (o.player === staticID) {
                if (o.success) {
                    refreshView();
                } else {
//                    alert(`no session with ID ${txt.value} exists`);
                    showWarning(`no session with ID ${txt.value} exists`);
                    showWarning(`no session with ID ${$('#seshnum').val()} exists`);
                }
            }
        };
        let requestSession = null;
        // requestSession is defined in the newlogin template
        const getHash = () => {
            let h = '';
            if (window.location.hash && isDev) {
                if (window.location.hash.substr(0, 1) === '#') {
                    h = window.location.hash.replace('#', '');
                    if (h.indexOf('?', 0) > -1) {
                        h = h.split('?')[0];
                    }
                }
            }
//            console.log(`getHash: ${h}, isDev: ${isDev}`);
//            console.log(JSON.parse(JSON.stringify(window.location)))
            return h;
        };
        const getStorageID = () => {
            let sid = `player${getHash()}ID`;
//            console.log(`sid set to ${sid}`);
            return sid;
        };
        const getUniqueStorageID = (id) => {
            return `${getStorageID()}-${id}`;
        };
        const generateID = () => {
//            console.log(`gen id`);
            let id = 'player-' + Math.round(Math.random() * 1000);
            if (window.location.hash) {
                if (window.location.hash.substr(0, 1) === '#') {
                    id = id.replace('-', '-' + window.location.hash.replace('#', '') + '-');
                    if (id.indexOf('?', 0) > -1) {
                        id = id.split('?')[0];
                    }
                }
            }
            if (id) {
                staticID = id;
                localStorage.setItem(getStorageID(), JSON.stringify({id: staticID}));
            }
            return id;
        };
        const getID = () => {
            let id = localStorage.getItem(getStorageID());
//            console.log(`getID; retrieve id from localStorage: ${id}`);
//            console.log(`storedID: ${id}`);
//            console.log(`staticID: ${staticID}`);
            if (!id) {
                id = generateID();
            } else {
                // we have the local storage object, now we must extract the id from it:
//                console.log('id:');
//                console.log(id);
                id = JSON.parse(id).id;
                staticID = id;
//                console.log(`ID retrieved from localStorage: ${id}`);
            }
//            staticID = id;
            return id;
        };
        const getMinID = () => {
            let id = getID().replace(env.gamedata.prefixes.player, '');
//            console.log(`getID call; getMinID method: ${id}`);
            return id;
        };
        const prepPlayer = (p) => {
            // Output a player object based on a retrieved object
            let s = p.stakeholder;
            p.stakeholderID = s;
            if (s < 0) {
                p.stakeholder = 'unassigned';
            } else {
                p.stakeholder = Object.values(env.gamedata.teams)[s].title;
            }
//            console.log(p);
            return p;
        };
        const finalisePlayer = (p) => {
            // Make any final tweaks to the player object before it is sent to the templates for rendering
            if (p.mainTeams && p.teamObj) {
                p.mainTeams.forEach((t) => {
                     t.isMyTeam = t.id === p.teamObj.id;
                });
            }
            if (p.teamObj) {
//                console.log(p.teamObj);
                if (p.teamObj.hasLead) {
                    p.actions = p.teamObj.hasOwnProperty('actions') ? p.teamObj.actions : env.gamedata.actions;
                }
            }
//            console.log(p);
            return p;
        };
        const newPlayer = () => {
//            console.log(`newPlayer called, id: ${id}`);
//            storageID = getStorageID();
//            document.title = id;
            player.enrolled = true;
//            $('h2').html(`id: ${id}`);
//            socket.emit('addNewPlayer', {id: id}, (response) => {
//                gameInit();
//            });
//            console.log(`newPlayer calls refreshView`);
            refreshView('newPlayer');
            gameInit();
        };
        const gameInit = () => {
//            console.log(`gameInit`);
            // this code is open to abuse, replace it with insertion of template HTML
            let sessionID = txt.value;
            renderGameScreen();
        };
        const clearPersistence = () => {
            localStorage.clear();
        };
        const kickout = () => {
            renderTemplate('outtro', 'insertion');
            clearPersistence();
        };
        const evicted = () => {
            renderTemplate('kickedout', 'insertion');
        };
        const refreshMe = () => {
            console.log(`I want refreshment`);
            window.location.reload()
        };
        const setupDragger = (dr) => {
            let d = $(`#${dr}`).find('.dragbar');
//            console.log($(`#dr`))
//            console.log(d)
            d.off('click');
            d.on('click', function () {
                console.log('start the drag');
            });
        };
        const renderTemplate = (temp, targ, o) => {
            targ = '#' + targ;
            let ob = Object.assign({}, o);
            const compiledTemplate = Handlebars.templates[temp];
            const renderedHtml = compiledTemplate(ob);
            $(targ).html('');
            $(targ).html(renderedHtml);
        };
        const getTemplate = () => {

        };
        const setState = (o) => {
            // record a state for the page to return to upon refresh
//            console.log(`setState`);
//            console.log(o);
            let st = JSON.stringify(o);
//            console.log(`storing ${st}`);
            localStorage.setItem(getUniqueStorageID('state'), st);
        };
        const shareState = (o) => {
            // in the case of PV voters, their votes are shared over the team, so set stored state for all team members via the server
            socket.emit('shareState', {d: o, src: player.id});
        }
        const updateState = () => {
            // return the page to its present state
//            console.log(`updateState`);
            let o = JSON.parse(localStorage.getItem(getUniqueStorageID('state')));
//            console.log(o);
            if (o) {
                if (o.hasOwnProperty('length')) {
//                    console.log('looks like an array');
                    o.forEach((v) => {
//                        console.log(v);
                        $(`#${v.option}`).val(v.val);
                        $(`#${v.option}`).attr('disabled', v.disabled);
                        $(`#${v.button}`).attr('disabled', v.disabled);
                    });
                } else {
                    for (var i in o) {
                        if ($(`#${i}`).length > 0) {
                            $(`#${i}`).val(o[i]);
                            $(`#${i}`).attr('disabled', true);
                        }
                    }
                }
            }
            scoreUpdate();
        };
        const updateValues = (pl) => {
//            console.log('pl');
//            console.log(pl);
            if (pl) {
                if (pl.hasOwnProperty(`teamObj`)) {
                    let list = ['votes', 'votesReceived', 'multiplier', 'total'];
                    let o = {
//                        votes: pl.teamObj.type === 1 ? pl.teamObj.votes : pl.votes,
                        votes: pl.teamObj.votes,
                        votesReceived: pl.teamObj.votesReceived,
                        multiplier: pl.teamObj.multiplier,
                        total: pl.teamObj.votesReceived * pl.teamObj.multiplier
                    }
//                    console.log(o);
                    let t = pl.teamObj;
                    let ob = null;
                    o = {vals: []};
                    list.forEach((l) => {
                        if (t.hasOwnProperty(l)) {
                            ob = {
                                prop: l,
//                                val: l === 'votes' ? (pl.teamObj.type === 1 ? t[l] : pl[l]) : t[l],
//                                val: l === 'votes' ? (pl.teamObj.type === 1 ? t[l] : pl[l]) : t[l],
                                val: t[l]
                            };
                            o.vals.push(ob);
                        }
                    });
                    if (o.vals.length > 0) {
                        renderTemplate('scoresheet', 'scoresheet', o);
                    }
                    if (pl.teamObj.hasOwnProperty('scores')) {
                        let o = Object.assign({partialName: 'erascores'}, pl.teamObj.scores.eras);
                        renderTemplate('dragwin', 'scoredisplay', o);
                        setupDragger('scoredisplay');
                    }
                }
            }
        };
        const renderGameScreen = () => {
            let o = {
                playerID: staticID
            };
            socket.emit('getPlayerPack', (o) => {
                let steak = player.stakeholderID;
                player = prepPlayer(o.playersDetail[getMinID()]);
                if (o.session.assigned) {
                    if (player.stakeholderID > -1) {
                        let mainTeam = Object.values(env.gamedata.teams)[player.stakeholderID].hasMax;
                        player.partialName = mainTeam ? 'stakeholder' : 'publicvoices';
                        if (player.isLead && document.title.indexOf('*', 0) < 0) {
                            document.title = `* ${document.title}`
                        }
                    }
                }
                player = Object.assign(env.gamedata, player);
                player = finalisePlayer(player);
                if (steak !== player.stakeholderID) {
                    // Only render if the stakeholder has changed -  may need to add other conditions later
                    renderTemplate('game', 'insertion', player);
                    updateState();
                }
            });
        };
        const onNewSession = () => {
            // Reload the page rather than refresh view - this enables script to run successfully on rendered page
            // Note: prior call to 'onStoredGameFound' causes a refresh, hence the flicker. Consider a way to remove this in future.
            clearPersistence();
            // Keep the line below in place for now, but work to remove it later.
            // Move the login code off the template and into the main page - page refreshing sucks.
            window.location.reload();
//            refreshView('onNewSession');
        };
        const updateMaxVotes = (m) => {
            max = m;
            $('#votes').html(m);
            console.log(`set max to ${m}`);
        };
        const connectionWarning = (boo) => {
//            console.log(`connectionWarning: ${boo}`);
            if (boo) {
                $('#overlay').html('');
            } else {
                renderTemplate('serverlost', 'overlay');
            }
//            clearTimeout(cInt);
//            cInt = setTimeout(() => {
//                if (boo) {
//                    $('#overlay').html('');
//                } else {
//                    renderTemplate('serverlost', 'overlay');
//                }
//            }, 2000);
        };
        const serverShutdown = () => {
//            $('body').fadeOut(2000);
            connectionWarning(false);
            suspend = true;
//            clearTimeout(cInt);
//            cInt = setTimeout(() => {
//                connectionWarning(false);
//            }, 2000);
        };
        const onPinged = () => {
//            $('H1').delay(10).fadeOut(50).fadeIn();
            let t = document.title;
            let n = 7;
            document.title = `*${t}`;
            let i = setInterval(() => {

                $('H1').css('opacity', `${n%2 === 0 ? 1 : 0.3}`);
                if (n-- === 0) {
                    clearInterval(i);
                    document.title = t;
                }
            }, 200);

        };
        const init = () => {
//            console.log('this is init ');
//            storageID = getStorageID();
//            console.log(`storageID: ${storageID}`)
//            console.log(`init, id: ${id}`)
        };
        let currentState = null;
        const refreshViewCallback = (p) => {
//            console.log(`refreshViewCallback`);
            let id = getMinID();
            let newPlayer = !p.playersBasic.hasOwnProperty(id);
            let enrolled = false;
            if (currentState) {
                let c = currentState !== JSON.stringify(p);
            }
            currentState = JSON.stringify(p);
            if (p.hasOwnProperty('playersDetail')) {
                if (p.playersDetail.hasOwnProperty(id)) {
                    enrolled = p.playersDetail[id].enrolled;
                } else {
//                    console.log(`%cno player with id ${id} found`, `color: red;`);
                }
            }
            if (p.sessionID) {
                if (enrolled) {
                    renderGameScreen();
                } else {
                    if ($('#insertion').find('#login').length === 0) {
                        console.log('render the login');
                        // only render the login if it isn't already there
                        renderTemplate('newlogin', 'insertion', {
                            value: p.isDev ? p.sessionID : ''
                        });
                    }
                }
            } else {
                renderTemplate('intro', 'insertion');
            }
        };
        let refreshing = false;
        const refreshView = () => {
//            console.log(`refreshView`);
//            console.log(`are we already refreshing? ${refreshing}`);
//            console.log(`refreshView, suspend? %c${suspend}`, `color: ${suspend ? 'green' : 'red'}`);
            // Do not run if suspend = true, i.e. server has shit down and is not yet ready to restart
            if (!suspend) {
                // cut out unecessary calls by not calling if a refresh is already in progress
                refreshing = false;
                if (!refreshing) {
                    refreshing = true;
                    socket.emit('getPlayerPack', (p) => {
                        //
                        // can we use the storedData in the playerPack to assess whether the player is enrolled?
                        //
                        refreshing = false;
                        refreshViewCallback(p);
                    });
                }
            } else {
//                console.log(`suspend is true, refreshing is not possible at this time`);
            }
        };
        const getInitProps = () => {
            let o = {};
            let p = window.location.hash;
//            console.log(p);
            if (p && p.indexOf('?', 0) > -1) {
                p = p.split('?');
//                    console.log(p);
                if (p.length > 0) {
//                    console.log(p);
                    p = p[1].split('&');
                    p.forEach((s) => {
                        let ps = s.split('=');
                        o[ps[0]] = ps[1];
                    });
                }
            }
//            console.log(o);
            return o;
        };
        const onConnect = () => {
            connectionWarning(true);
//            console.log('onconnect event');
            socket.emit('getPlayerPack', (p) => {
//                console.log('playerPack')
//                console.log(p)
//                console.log(player);
                isDev = p.isDev;
                env = Object.assign({}, p);
                if (Boolean(p.session)) {
                    let id = getMinID();
                    clientData.id = id;
                    socket.emit('customDataEvent', clientData);
                    id = getID();
                    storageID = getStorageID();
                    document.title = id;
//                    console.log(p);
                    $('h2').html(`id: ${id}`);
                    socket.emit('addNewPlayer', {id: id}, (o) => {
                        player = o.player;
//                        console.log(player);
                    });
                    let sid = false;
                    if (p.storedData) {
                        if (p.storedData.hasOwnProperty('sid')) {
                            sid = p.storedData.sid;
                        }
                    }
                } else {
                    console.log(`no session in progess, don't create a player yet - just show the intro`);
                    renderTemplate('intro', 'insertion');
                }
            });
        };

        let isDev = false;
        let logList = {};
        let autoTO = null;

        // Potential universal code:


        const showWarning = (w) => {
            $('#warning_message').html(w);
            $('#warning').show();
        };
        const closeWarning = () => {
            $('#warning').hide();
        };
        const procVal = (v) => {
            let rv = v;
            if (rv === 'true') {
                rv = true;
            }
            if (rv === 'false') {
                rv = false;
            }
            return rv;
        };

        // end potential universal code


        // Type-specific code:

        // Public Voices
        let vb = $('.buttonVote');
        let vv = $('.voteVal');
        let max = 10;
        let ls = [];
        let lid = null;
        const validateVote = (inp) => {
            if ($(inp).is(':visible')) {
                const value = parseFloat(inp.value);
                if (value > max) {
                    inp.value = max;
                }
                if (value < (-1 * max)) {
                    inp.value = (-1 * max);
                }
//                console.log(max, inp.value);
            }
        };
        const inputsDisabled = (src, pre) => {
            const vi = src.parent().find('.voteVal');
            let ad = pre === undefined ? false : pre;
            if (!ad) {
                ad = true;
                vb.each((i, v) => {
                    // if the button is the same as the clicked button this can't set rc to false (because we know this button is disabled)
                    if ($(v).attr('disabled') !== 'disabled' && $(v).attr('id') !== src.attr('id')) {
                        ad = false;
                    }
                });
            }
            return ad;
        };
        const submitVote = function (src, toEmit) {
            const vi = src.parent().find('.voteVal');
            let rc = inputsDisabled(src, player.teamObj.votes - parseInt(vi.val()) <= 0);
//            console.log(`ac: ${rc}`);
            let so = {
                src: player.id,
                targ: parseInt(vi.attr('id').split('_')[1]),
                valID: 'vote',
                val: parseInt(vi.val()),
                round: env.session.round,
                roundComplete: rc
            }
//            console.log('get it here');
            registerScore2(so);
        };
        const submitVotev2 = function (src, toEmit) {
            /*
            This method modified to include the new 'inputsDisabled' method, which checks whether all text inputs a
            on a page are disabled (meaning the form is complete).
            Old method retained in case of failure.
            */
            const vi = src.parent().find('.voteVal');
            let rc = inputsDisabled(src, player.teamObj.votes - parseInt(vi.val()) <= 0);
//            console.log(`ad: ${inputsDisabled(src, rc)}`);
//            if (!rc) {
//                rc = true;
//                vb.each((i, v) => {
//                    // if the button is the same as the clicked button this can't set rc to false (because we know this button is disabled)
//                    if ($(v).attr('disabled') !== 'disabled' && $(v).attr('id') !== src.attr('id')) {
//                        rc = false;
//                    }
//                });
//            }
            console.log(`ac: ${rc}`);

            let so = {
                src: player.id,
                targ: parseInt(vi.attr('id').split('_')[1]),
                valID: 'vote',
                val: parseInt(vi.val()),
                roundComplete: rc
            }
            registerScore2(so);
        };
        const submitVoteV1 = function (src, toEmit) {
            const vi = src.parent().find('.voteVal');
            let o = {
                src: player.id,
                team: player.stakeholderID,
                targ: parseInt(vi.attr('id').split('_')[1]),
                v: parseInt(vi.val())
            };
            console.log('submitVote');
//            console.log(o);
            ls[o.targ] = o.v;
            localStorage.setItem(lid, ls);
            src.attr('disabled', true);
            vi.attr('disabled', true);
//            socket.emit(toEmit, o);

            //
            registerScore(player.id, parseInt(vi.attr('id').split('_')[1]), 'vote', parseInt(vi.val()));
        };
        vv = $('.voteVal');
        const getRemain = () => {
            let m = max;
            if (vv) {
                vv.each(function () {
                    let v = Math.abs(parseInt($(this).val()));
                    m -= v;
//                    console.log(v, m)
                });
            }
            return m;
        };
        const autoCompleteAllowed = () => {
            return procVal(env.process.AUTO);
        };

        const autoEnrollAllowed = () => {
//            return true;
            return procVal(env.process.AUTOENROL);
        };
        const allowAutoComplete = () => {
            let m = 2;
//            return false;
            return env.session.round < m ? autoCompleteAllowed() : false;
        };
        const autoCompleteCollaboration = () => {
//            console.log(`autoCompleteCollaboration: ${allowAutoComplete()}`);
            if (allowAutoComplete()) {
                let v = $('.voteVal');
                let b = $('.buttonVote');
                let vt = player.teamObj.votes;
                let div = $('.voteVal').length - 1;
                let min = Math.floor(vt / div);
                let over = vt - (min * div);
                let a = Array.from({length: div}, () => min);
                console.log(vt, min, over);
                while (over > 0) {
                    a[Math.floor(Math.random() * a.length)] += 1;
                    over--;
                }
                a.sort(() => {return Math.round(Math.random() * 3 - 2)});
//                console.log(a);
                a.push(0);
//                autoCompleteAllowed = false;
                a.forEach((av, i) => {
                    $(v[i]).val(av);
//                    $(b[i]).click();
                });
                b.click();
                setTimeout(() => {
                    $(b[0]).click();
                }, 5000);
            }
        };
        const autoCompleteAllocation = () => {
            if (allowAutoComplete()) {
//                console.log(`I will autoCompleteAllocation`);
                let sel = $('#actionSelect');
                let desc = $('#actionDesc');
                let val = $('#allocateVal');
                if (sel.length === 0 || desc.length === 0 || val.length === 0) {
//                    console.log(`no I won't, wrong type`);
                    return;
                }
                if (!Boolean(sel.val()) && !Boolean(desc.val()) && !Boolean(val.val())) {
                    let op = $('#actionSelect option');
                    let ri = Math.ceil(Math.random() * (op.length - 1));
                    let ro = op.eq(ri);
                    sel.val(ro.val());
                    desc.val('a test description');
                    let opval = Math.ceil(Math.random() * 4);
//                    console.log(`setting op to ${ri}`);
                    val.val(opval);
                    if (Boolean(sel.val()) && Boolean(desc.val()) && Boolean(val.val())) {
                        $('#buttonAllocate').click();
//                        let tot = 500 + (Math.random() * 500);
//                        autoCompleteAllowed = false;
//                        setTimeout(() => {
//                            console.log(`the click`);
//                            $('#buttonAllocate').click();
//                        }, tot);
                    } else {
//                        console.log(`not enough info, try again`);
                        setTimeout(300, autoCompleteAllocation);
                    }
                }
            }
        };
        const updateSession = (s) => {
            if (JSON.stringify(s) !== JSON.stringify(env.session)) {
//                console.log(`old session: ${JSON.stringify(env.session)}`);
                Object.assign(env.session, s);
//                console.log(`new session: ${JSON.stringify(env.session)}`);
            } else {
                console.log(`updateSession called but no change detected`);
            }
        };
        const viewUpdate = () => {
            clearTimeout(autoTO);
            socket.emit('getPlayerPack', (pp) => {
                console.log(`getPlayerPack:`);
                console.log(pp);
                updateSession(pp.session);
                enableScorePV(pp.session.round > 0);
                $('.round').hide();
                if (pp.session.round > 0) {
                    let theDiv = env.gamedata.rounds[pp.session.round].id.split('_')[0];
                    $('.round').hide();
                    $(`#${theDiv}`).show();
                    $(`.round${pp.session.round}`).show();
                    updateState();
                    let s = localStorage.getItem(lid);
                    if (s) {
                        debugServer(`stored data: ${s}`);
                        s = s.split(',');
                        max = 10;
                        s.forEach((v, i) => {
                            if (!isNaN(parseInt(v))) {
                                max -= parseInt(v);
                                ls[i] = v;
                                vv[i].value = v;
                                $(vv[i]).attr('disabled', true);
                                $(vb[i]).attr('disabled', true);
                            }
                        });
                    }
                    if (getInitProps().autoenroll && pp.session.round < 3 && player.isLead && player.teamObj.type === 1) {
                        let tot = (player.teamObj.id + 1) * 200;
                        clearTimeout(autoTO);
                        autoTO = setTimeout(pp.session.round === 1 ? autoCompleteAllocation : autoCompleteCollaboration, tot);
                    }
                }
            });
        };
        const onSessionUpdate = (s) => {
            console.log('==================== session update calls viewUpdate');
            console.log(s);
            viewUpdate();
        };

        const submitMultiplier = function (src, toEmit) {
            const vi = src.parent().find('.voteVal');
            const viz = vi.is(':visible');
//            console.log(vi.val(), max, viz);
            if (vi.val() > max) {
                alert(`sorry, you only have ${max} votes left`);
            } else {
    //            console.log(`viz: ${viz}`);
                let rc = inputsDisabled(src, false);
                let so = {
                    src: player.id,
                    targ: parseInt(vi.attr('id').split('_')[1]),
                    valID: 'vote',
                    isMultiplier: true,
                    val: parseInt(vi.val()),
                    roundComplete: rc
                }
                registerScore2(so);
                so = [];
                vv.each((id, v) =>  {
                    let st = JSON.parse(localStorage.getItem(getUniqueStorageID('state')));
                    let vid = $(v).attr('id').split('_')[1];
                    let o = {
                        option: $(v).attr('id'),
                        button: `buttonVote_${vid}`,
                        val: $(v).val(),
                        disabled: $(v).attr('id').split('_')[1] === src.attr('id').split('_')[1]
                    };
                    if (st) {
                        if (st.hasOwnProperty('length')) {
                            o.disabled = st[id].disabled ? true : o.disabled;
                        }
                    }
                    so.push(o);
                });
                shareState(so);
//                setState(so);
            }
        };
        const initpv = () => {
            debugServer('initialise a Public Voice');
            lid = `pv-${getID().split('?')[0]}-vote`;
            vb = $('.buttonVote');
            vv = $('.voteVal');
            vb.on('click', function () {
                submitMultiplier($(this), 'pvStakeholderScore');
            });
            viewUpdate();
//            scoreUpdate(getMinID());
        };
        // MAJOR function; should be reorganised & split up:
        const renderVotes = (p) => {
//            console.log(`renderVotes`);
//            console.log(p);
            if (!p.hasOwnProperty(`teamObj`)) {
                return;
            }
            let v = p.teamObj.votes;
//            let m = p.teamObj.multiplier;
//            let t = parseInt(v) * parseInt(m);
//            console.log(v, m, t);
            let rc = player.teamObj.votes === 0;
            debugServer(`renderVotes called`);
            $('#votes').html(v);
//            $('.multiplier').html(m);
//            $('.totalscore').html(t);
            max = v;
            let c = 0;
            vv.each((i, el) => {
//                console.log(i, $(el).attr('id'), $(el).prop('disabled'), $(el).is(':visible'));
                c+= $(el).prop('disabled') && $(el).is(':visible') ? 1 : 0;
                if (!$(el).prop('disabled')) {
                    validateVote(el);
                }
            });
//            console.log(`${c} out of ${vv.length}`);
            // condition: input boxes exist, are all filled and no round score already held
            let boxes = c === vv.length && vv.length > 0;
            let newRound = player.teamObj.rounds.toString().indexOf(env.session.round) < 0;
            let remain = Boolean(player.teamObj.votes);
            let isLead = player.isLead;
            let isType = player.teamObj.type === env.gamedata.rounds[env.session.round].type;
            /* isType checks to see if this player can score in this round */
            let ok = ((boxes && newRound) || (!remain && newRound)) && isLead && isType;
            ///*
//            if (env.session.round === 3) {
//                console.log(` ===== renderVotes: ${ok} round ${env.session.round}`);
//            }
            /*
            console.log(`boxes: ${boxes}`);
            console.log(`newRound: ${newRound}`);
            console.log(`remain: ${remain}`);
            console.log(`isLead: ${isLead}`);
            console.log(`isType: ${isType}`);
            */
            //*/
//            console.log(player.teamObj.votes);
//            console.log(player.teamObj.rounds.toString().indexOf(env.session.round) < 0);
//            console.log(env.session.round)
            if (ok) {
//                console.log('EMIT');
//                console.log(p);
                socket.emit('teamRoundComplete', {team: p.teamObj.id, player: p.id})
            }
            if (v <= 0) {
                $('#votes').addClass('false');
                vb.attr('disabled', true);
                vv.attr('disabled', true);
            }
        };
        const updatePlayer = (p) => {
            if (JSON.stringify(player.teamObj) !== JSON.stringify(p.teamObj)) {
//                console.log(JSON.parse(JSON.stringify(player.teamObj)));
                Object.assign(player.teamObj, p.teamObj);
//                console.log(JSON.parse(JSON.stringify(player.teamObj)));
            }
        };
        const scoreUpdate = (o) => {
            //forget the incoming object, it's a red herring, go to the server for the player object instead
//            console.log(`scoreUpdate`);
//            console.log(o);
            socket.emit('getPlayer', getMinID(), (p) => {
//                console.log(`getPlayer CB:`);
                updatePlayer(p);
                renderVotes(p);
                updateValues(p);
            });
        }
        const scoreUpdateV1 = (o) => {
//            console.log(`scoreUpdate:`);
//            console.log(o);
//            console.log(getMinID());
            // Conditional modified to always be true - this method is sent to all team members, hence can always run. Check to see whether the event is emitted in other methods, if not we can get rid of the conditional, if it is then the conditional needs to be modified to match the team ID.
            if (o.src === getMinID()) {
                console.log(`OK, we can go`);
                socket.emit('getPlayer', o.src, (p) => {
                    console.log(`getPlayer CB:`);
                    console.log(p);
                    renderVotes(p);
                    updateValues(p);
                });
            } else {
                console.warn('ID mismatch, cannot update');
            }
        };
        const enableScorePV = (boo) => {
//            console.log(`enableScorePV`);
            vb.prop('disabled', !boo);
            vv.prop('disabled', !boo);
        };
        $('.buttonVote').on('click', submitVote);

        const setupPV = () => {
            initpv();
        };
        socket.on('scoreUpdate', (o) => {
            scoreUpdate(o);
        });
        // End Public Voices

        // Stakeholder
        const registerScore2 = (o) => {
            socket.emit('getNewScorePacket2', o);
            console.log('getNewScorePacket2');
            console.log(o);
        }
        const registerScore = (src, targ, valID, val) => {
            console.log(`registerScore`, src, targ, valID, val);
            registerScore2(`registerScore`, src, targ, valID, val);
            socket.emit('getNewScorePacket', src, targ, valID, val, (sp) => {
//                console.log(sp);
            })
        };
        const initst = () => {
            $('body').addClass(player.teamObj.stub)
            $('body').addClass(player.isLead ? 'lead' : 'member')
            lid = `st-${getID().split('?')[0]}-vote`;
            vb = $('.buttonVote');
            vv = $('.voteVal');
            vb.on('click', function () {
                let d = $(this).attr('id');
                let o = {};
                let a = [];
                let st = JSON.parse(localStorage.getItem(getUniqueStorageID('state')));
                $('.voteVal').each(function (i, vo) {
                    o = {
                        option: $(this).attr('id'),
                        button: `buttonVote_${$(this).attr('id').split('_')[1]}`,
                        val: $(this).val(),
                        disabled: d.split('_')[1] === $(this).attr('id').split('_')[1]
                    }
                    if (st) {
                        if (st.hasOwnProperty('length')) {
                            o.disabled = st[i].disabled ? true : o.disabled;
                        }
                    }
                    a.push(o);
                });
                setState(a);
                submitVote($(this), 'stStakeholderScore');
            });
            //
            // Allocation - non-collaborative self-allocation of resources
            let ab = $('#buttonAllocate');
            let av = $('#allocateVal');
            let as = $('#actionSelect');
            let ad = $('#actionDesc');
            ab.on('click', function () {
//                console.log(`I am the click`);
                if (Boolean(as.val()) && Boolean(av.val()) && Boolean(ad.val())) {
                    if (av.val() < 1) {
                        alert('value must be more than 0');
                    } else {
                        let c = getInitProps().autoenroll ? true :  confirm('are you sure?');
                        if (c) {
//                            registerScore(player.id, player.teamObj.id, 'action_name', as.val());
                            registerScore2({src: player.id, targ: player.teamObj.id, valID: 'action_name', val: as.val()});
//                            registerScore(player.id, player.teamObj.id, 'action_desc', ad.val());
                            registerScore2({src: player.id, targ: player.teamObj.id, valID: 'action_desc', val: ad.val()});
//                            registerScore(player.id, player.teamObj.id, 'vote', parseInt(av.val()));
                            registerScore2({src: player.id, targ: player.teamObj.id, valID: 'vote', val: parseInt(av.val()), roundComplete: true});
                            let sto = {
                                allocateVal: av.val(),
                                actionDesc: ad.val(),
                                actionSelect: as.val(),
                                buttonAllocate: ''
                            };
                            setState(sto);
                            let o = {
                                src: player.id,
                                t: player.teamObj.id,
                                action_name: as.val(),
                                action_desc: ad.val(),
                                resource: parseInt(av.val())
                            };
                            ab.attr('disabled', true);
                            av.attr('disabled', true);
                            as.attr('disabled', true);
                            ad.attr('disabled', true);
    //                        scoreUpdate(o);
    //                        socket.emit('allocation1', o);
                        }
                    }
                } else {
                    alert('please complete all options');
                }

            });

            viewUpdate();
        };
        const setupStakeholder = () => {
            initst();
        };

        const validateAllocation = (inp) => {
            const value = parseFloat(inp.value);
            if (value > max) {
                inp.value = max;
            }
            if (value < 0) {
                inp.value = 0;
            }
        };
        // End stakeholder

        // End type-specific code




        socket.on('onRequestSession', (boo) => {
            onRequestSession(boo);
        });
        socket.on('connect', () => {
//            console.log(`connect calls onConnect: ${socket.id}`);
            onConnect();
        });
        socket.on('onStoredGameFound', () => {
//            console.log('onStoredGameFound calls refreshView');
//            suspend = false;
            refreshView(`onStoredGameFound`);
        });
        socket.on('onUpdateTimer', (t) => {
            let p = $('#gameTimer');
            p.html(t);
        });
        socket.on('terminateSession', kickout);
        socket.on('sessionUpdate', (s) => {
            onSessionUpdate(s);
        });
        socket.on('newSession', onNewSession);
        socket.on('serverShutdown', serverShutdown);
        socket.on('ping', () => {
            onPinged();
//            console.log(`i got pinged`);
        });
        socket.on('refresh', () => {
            refreshMe();
        });
        socket.on('evict', () => {
            evicted();
        });
        socket.on('onAssignTeams', (id) => {
            return;
//            console.log(`I have a Team: ${id}`);
//            console.log(env.gamedata.teams[id]);
//            console.log(env.gamedata.teams);
            $('#team').find('span').html(env.gamedata.teams[id].title);
//            debugger;
        });
        socket.on('upateMaxVotes', (m) => {
//            console.log('i heard the emission')
            updateMaxVotes(m)
        });
        socket.on('shareStored', (d) => {
//            console.log('NEW')
            setState(d);
            updateState();
        });
        window.showLog = getLogs;
        window.getRemain = getRemain;
        //
        //        init();

    </script>
</body>

</html>
